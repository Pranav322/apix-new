require("dotenv").config();
const express = require("express");
const multer = require("multer");
const SFTPClient = require("ssh2-sftp-client");
const mongoose = require("mongoose");
const fs = require("fs");
const path = require("path");
const { exec } = require("child_process");
const stream = require('stream');
const cors = require('cors');
const Razorpay = require("razorpay");
const crypto = require('crypto');
const app = express();

app.use(cors({
  origin: '*',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
app.use(express.json());
const port = process.env.PORT || 4000;

mongoose
  .connect(process.env.MONGO_URI, { useNewUrlParser: true })
  .then(() => console.log("✅ Connected to MongoDB"))
  .catch((err) => console.error("❌ MongoDB connection error:", err));

const movieSchema = new mongoose.Schema({
  title: String,
  category: String,
  description: String,
  hlsUrl: String,
  trailerUrl: String,
  thumbnailUrl: String,
  uploadDate: { type: Date, default: Date.now },
  status: { type: String, default: 'processing' },
  type: { type: String, enum: ['movie', 'show'], required: true },
  rentalPrice: { type: Number, required: function() { return this.type === 'movie' || this.type === 'show'; } },
  rentalDuration: { type: Number, default: 48 },
  seasons: [{
    seasonNumber: { type: Number, required: true },
    rentalPrice: { type: Number, required: true },
    episodes: [{
      title: String,
      description: String,
      hlsUrl: String,
      thumbnailUrl: String,
      uploadDate: { type: Date, default: Date.now },
      status: { type: String, default: 'processing' },
      rentalPrice: { type: Number, required: true }
    }]
  }]
});

const Movie = mongoose.model("Movie", movieSchema);

const User = require("./models/User");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const Rental = require("./models/Rental");
const Wishlist = require("./models/Wishlist");

// File size validation middleware
const fileFilter = (req, file, cb) => {
  // Initially accept the file
  cb(null, true);
};

// Use disk storage with validation
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const tempDir = path.join('/tmp', 'uploads', new Date().toISOString().replace(/:/g, '-'));
    fs.mkdirSync(tempDir, { recursive: true });
    cb(null, tempDir);
  },
  filename: function (req, file, cb) {
    cb(null, file.originalname);
  }
});

// Set file size limits and validation
const upload = multer({ 
  storage,
  fileFilter,
  limits: { 
    fileSize: 15 * 1024 * 1024 * 1024, // 15GB limit
    fieldSize: 15 * 1024 * 1024 * 1024 // Also set field size limit
  }
});

// Middleware to verify uploaded files
const verifyUploadedFiles = (req, res, next) => {
  if (!req.files) {
    return res.status(400).json({ error: "No files were uploaded" });
  }

  const verifyFile = (file) => {
    if (!file || !file.size || file.size === 0) {
      throw new Error(`File ${file.originalname} is empty or corrupted`);
    }
    // Check if file exists on disk
    const exists = fs.existsSync(file.path);
    const stats = fs.statSync(file.path);
    if (!exists || stats.size === 0) {
      throw new Error(`File ${file.originalname} failed to save properly`);
    }
    return true;
  };

  try {
    // Verify each type of file
    if (req.files.video) {
      req.files.video.forEach(verifyFile);
    }
    if (req.files.trailer) {
      req.files.trailer.forEach(verifyFile);
    }
    if (req.files.thumbnail) {
      req.files.thumbnail.forEach(verifyFile);
    }
    next();
  } catch (err) {
    // Clean up any uploaded files
    Object.values(req.files).flat().forEach(file => {
      if (file.path && fs.existsSync(file.path)) {
        fs.unlinkSync(file.path);
      }
    });
    return res.status(400).json({ error: err.message });
  }
};

// Function to verify file completion
function verifyFile(filePath) {
  return new Promise((resolve, reject) => {
    const maxAttempts = 10;
    let attempts = 0;
    
    const checkFile = () => {
      try {
        // Try to open and read the file
        const fd = fs.openSync(filePath, 'r');
        fs.closeSync(fd);
        
        // Get file stats
        const stats = fs.statSync(filePath);
        
        // Check if file size is greater than 0
        if (stats.size > 0) {
          resolve();
        } else {
          throw new Error('File is empty');
        }
      } catch (err) {
        attempts++;
        if (attempts >= maxAttempts) {
          reject(new Error(`File verification failed after ${maxAttempts} attempts: ${err.message}`));
        } else {
          // Wait 2 seconds before next attempt
          setTimeout(checkFile, 2000);
        }
      }
    };
    
    checkFile();
  });
}

const sftpConfig = {
  host: process.env.SFTP_HOST,
  port: 22,
  username: process.env.SFTP_USER,
  password: process.env.SFTP_PASS,
  readyTimeout: 120000,
  keepaliveInterval: 20000,
  keepaliveCountMax: 10,
};

const outputDir = '/tmp/hls_output';

// Ensure the directory exists
if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
}

async function convertToHLS(inputPath, outputFolder) {
  return new Promise((resolve, reject) => {
    const hlsPath = path.join(outputFolder, "master.m3u8");
    
    const ffmpegCmd = `
      ffmpeg -i ${inputPath} \
  -map 0:v -map 0:a? -c:v libx264 -crf 23 -maxrate 2000k -bufsize 4000k -vf "scale=1280:720" -c:a aac -ar 48000 -b:a 128k \
  -hls_time 6 -hls_list_size 0 -hls_segment_filename "${outputFolder}/720p_%03d.ts" -hls_playlist_type vod "${outputFolder}/720p.m3u8" \
  -map 0:v -map 0:a? -c:v libx264 -crf 23 -maxrate 1000k -bufsize 2000k -vf "scale=854:480" -c:a aac -ar 48000 -b:a 128k \
  -hls_time 6 -hls_list_size 0 -hls_segment_filename "${outputFolder}/480p_%03d.ts" -hls_playlist_type vod "${outputFolder}/480p.m3u8" \
  -map 0:v -map 0:a? -c:v libx264 -crf 23 -maxrate 600k -bufsize 1200k -vf "scale=640:360" -c:a aac -ar 48000 -b:a 128k \
  -hls_time 6 -hls_list_size 0 -hls_segment_filename "${outputFolder}/360p_%03d.ts" -hls_playlist_type vod "${outputFolder}/360p.m3u8"
    `;
    
    exec(ffmpegCmd, (error, stdout, stderr) => {
      if (error) {
        console.error(`❌ FFmpeg Error: ${stderr}`);
        reject(error);
        return;
      }
      
      const masterContent = `#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:BANDWIDTH=2128000,RESOLUTION=1280x720
720p.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=1128000,RESOLUTION=854x480
480p.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=728000,RESOLUTION=640x360
360p.m3u8`;
      
      fs.writeFileSync(hlsPath, masterContent);
      console.log(`✅ HLS Conversion Complete: ${hlsPath}`);
      resolve(hlsPath);
    });
  });
}

async function uploadToSFTP(sftp, localPath, remotePath) {
  try {
    const stats = fs.statSync(localPath);
    if (stats.isDirectory()) {
      const files = fs.readdirSync(localPath);
      for (const file of files) {
        await uploadToSFTP(sftp, path.join(localPath, file), `${remotePath}/${file}`);
      }
      return `https://theapix.in${remotePath.replace("/home/theapix/public_html", "")}`;
    }
    
    const remoteDir = path.dirname(remotePath);
    await sftp.mkdir(remoteDir, true);
    
    const readStream = fs.createReadStream(localPath);
    await sftp.put(readStream, remotePath);
    console.log(`✅ Uploaded: ${remotePath}`);
    return `https://theapix.in${remotePath.replace("/home/theapix/public_html", "")}`;
  } catch (err) {
    console.error(`❌ SFTP Upload Error: ${err}`);
    throw err;
  }
}

async function processUploadedFiles(files, movieDoc, category, title) {
  const movieId = movieDoc._id;
  const movieFolder = `/home/theapix/public_html/movies/${category}/${title}/`;
  const sftp = new SFTPClient();

  try {
    await sftp.connect(sftpConfig);
    await sftp.mkdir(movieFolder, true);
    
    let hlsUrl = null;
    let trailerUrl = null;
    let thumbnailUrl = null;

    if (files["video"]) {
      const videoPath = files["video"][0].path;
      const videoOutputDir = path.join(outputDir, movieId.toString());
      
      if (!fs.existsSync(videoOutputDir)) {
        fs.mkdirSync(videoOutputDir, { recursive: true });
      }

      // Add file verification before processing
      await verifyFile(videoPath);
      
      await updateMovieStatus(movieId, 'converting');
      await convertToHLS(videoPath, videoOutputDir);
      
      await updateMovieStatus(movieId, 'uploading');
      await sftp.mkdir(`${movieFolder}video`, true);
      
      await uploadToSFTP(sftp, videoOutputDir, `${movieFolder}video`);
      hlsUrl = `https://theapix.in/movies/${category}/${title}/video/master.m3u8`;
      
      fs.rmSync(videoOutputDir, { recursive: true, force: true });
      fs.rmSync(videoPath, { force: true });
    }

    if (files["trailer"]) {
      const trailerPath = files["trailer"][0].path;
      await verifyFile(trailerPath);
      
      await sftp.mkdir(`${movieFolder}trailer`, true);
      trailerUrl = await uploadToSFTP(
        sftp, 
        trailerPath, 
        `${movieFolder}trailer/${path.basename(trailerPath)}`
      );
      fs.rmSync(trailerPath, { force: true });
    }

    if (files["thumbnail"]) {
      const thumbnailPath = files["thumbnail"][0].path;
      await verifyFile(thumbnailPath);
      
      await sftp.mkdir(`${movieFolder}thumbnail`, true);
      thumbnailUrl = await uploadToSFTP(
        sftp, 
        thumbnailPath, 
        `${movieFolder}thumbnail/${path.basename(thumbnailPath)}`
      );
      fs.rmSync(thumbnailPath, { force: true });
    }

    await sftp.end();

    await Movie.findByIdAndUpdate(movieId, {
      hlsUrl,
      trailerUrl,
      thumbnailUrl,
      status: 'completed'
    });
    
    console.log(`✅ Processing completed for movie/show: ${title}`);
  } catch (err) {
    console.error(`❌ Processing failed: ${err.message}`);
    await updateMovieStatus(movieId, 'failed', err.message);
    throw err;
  }
}

async function updateMovieStatus(movieId, status, errorDetails = null) {
  const updateData = { status };
  if (errorDetails) {
    updateData.errorDetails = errorDetails;
  }
  await Movie.findByIdAndUpdate(movieId, updateData);
}

// Authentication middleware
const authenticateJWT = (req, res, next) => {
  const token = req.header("Authorization")?.split(" ")[1];
  if (!token) return res.sendStatus(403);

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
};

// Initialize Razorpay
const razorpay = new Razorpay({
  key_id: process.env.RAZORPAY_KEY_ID,
  key_secret: process.env.RAZORPAY_KEY_SECRET
});

// Upload endpoint
app.post("/upload", 
  upload.fields([
    { name: "video" }, 
    { name: "trailer" }, 
    { name: "thumbnail" }
  ]),
  verifyUploadedFiles,
  async (req, res) => {
    const { title, category, description, type, rentalPrice, seasons } = req.body;

    if (!title || !category || !type) {
      return res.status(400).json({ error: "Title, category, and type are required" });
    }

    if (!req.files || (!req.files.video && !req.files.trailer && !req.files.thumbnail)) {
      return res.status(400).json({ error: "At least one media file is required" });
    }

    if (type === 'movie') {
      if (!rentalPrice) {
        return res.status(400).json({ error: "Rental price is required for movies" });
      }
      if (seasons) {
        return res.status(400).json({ error: "Seasons should not be provided for movies" });
      }
    } else if (type === 'show') {
      if (!seasons || seasons.length === 0) {
        return res.status(400).json({ error: "Seasons are required for shows" });
      }
    
        for (const season of seasons) {
          if (!season.rentalPrice) {
            return res.status(400).json({ error: "Rental price is required for each season" });
          }
          for (const episode of season.episodes) {
            if (!episode.rentalPrice) {
              return res.status(400).json({ error: "Rental price is required for each episode" });
            }
          }
        }
      }
  
      const newMovie = new Movie({ 
        title, 
        category, 
        description, 
        type, 
        rentalPrice: type === 'movie' ? rentalPrice : undefined,
        seasons: type === 'show' ? seasons : undefined,
        status: 'processing'
      });
  
      await newMovie.save();
  
      res.json({ 
        message: "Upload processing started", 
        movieId: newMovie._id,
        status: 'processing'
      });
  
      processUploadedFiles(req.files, newMovie, category, title).catch(err => {
        console.error("Background processing error:", err);
        updateMovieStatus(newMovie._id, 'failed', err.message);
      });
  });
  
  // Get movie status endpoint
  app.get("/movies/:id/status", async (req, res) => {
    try {
      const movie = await Movie.findById(req.params.id);
      if (!movie) {
        return res.status(404).json({ error: "Movie not found" });
      }
      res.json({ 
        id: movie._id,
        title: movie.title,
        status: movie.status,
        errorDetails: movie.errorDetails,
        hlsUrl: movie.hlsUrl
      });
    } catch (err) {
      res.status(500).json({ error: "Failed to fetch movie status" });
    }
  });
  
  // Get Movies Endpoint
  app.get("/movies", async (req, res) => {
    try {
      const { category, type, limit = 20, page = 1 } = req.query;
      const skip = (page - 1) * limit;
  
      const query = {};
      if (category) query.category = category;
      if (type) query.type = type;
  
      const [movies, total] = await Promise.all([
        Movie.find(query)
          .sort({ uploadDate: -1 })
          .skip(skip)
          .limit(parseInt(limit))
          .lean(),
        Movie.countDocuments(query)
      ]);
  
      res.json({
        movies,
        pagination: {
          total,
          page: parseInt(page),
          pages: Math.ceil(total / limit)
        }
      });
    } catch (err) {
      res.status(500).json({ error: "Failed to fetch movies" });
    }
  });
  
  // Search Movies Endpoint
  app.get("/movies/search", async (req, res) => {
    try {
      const { query } = req.query;
      const searchRegex = new RegExp(query, 'i');
  
      const movies = await Movie.find({
        $or: [
          { title: searchRegex },
          { category: searchRegex }
        ]
      }).lean();
  
      res.json(movies);
    } catch (err) {
      res.status(500).json({ error: "Failed to search movies" });
    }
  });
  
  // User Registration
  app.post("/auth/register", async (req, res) => {
    const { username, password, email } = req.body;
    const hashedPassword = await bcrypt.hash(password, 10);
  
    const newUser = new User({ username, password: hashedPassword, email });
    await newUser.save();
    res.status(201).json({ message: "User registered successfully" });
  });
  
  // User Login
  app.post("/auth/login", async (req, res) => {
    const { email, password } = req.body;
    const user = await User.findOne({ email });
  
    if (!user || !(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ error: "Invalid credentials" });
    }
  
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: "1h" });
    res.json({ token });
  });
  
  // Get Current User Details
  app.get("/auth/me", authenticateJWT, async (req, res) => {
    const user = await User.findById(req.user.id).select("-password");
    res.json(user);
  });
  
  // Start the server
  app.listen(port, () => console.log(`🚀 Server running on http://localhost:${port}`));